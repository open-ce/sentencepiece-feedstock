From eb372c90530254a3f4deb45c77d257adfab2536f Mon Sep 17 00:00:00 2001
From: Deepali Chourasia <deepch23@in.ibm.com>
Date: Mon, 15 May 2023 07:25:28 +0100
Subject: [PATCH] fix for Swap32 build error on s390x

---
 src/common.h      | 10 ++++++----
 src/normalizer.cc | 10 ++++++----
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/src/common.h b/src/common.h
index ef5546d..b38b3f7 100644
--- a/src/common.h
+++ b/src/common.h
@@ -79,10 +79,6 @@ char (&ArraySizeHelper(const T (&array)[N]))[N];
 #endif
 #endif
 
-#ifdef IS_BIG_ENDIAN
-inline uint32 Swap32(uint32 x) { return __builtin_bswap32(x); }
-#endif
-
 namespace sentencepiece {
 #ifdef OS_WIN
 namespace win32 {
@@ -90,6 +86,12 @@ std::wstring Utf8ToWide(const absl::string_view input);
 }  // namespace win32
 #endif
 
+#ifdef IS_BIG_ENDIAN
+namespace util {
+inline uint32 Swap32(uint32 x) { return __builtin_bswap32(x); }
+}  // namespace util
+#endif
+
 namespace error {
 
 void Abort();
diff --git a/src/normalizer.cc b/src/normalizer.cc
index 2ab8084..450b7a9 100644
--- a/src/normalizer.cc
+++ b/src/normalizer.cc
@@ -264,9 +264,11 @@ std::string Normalizer::EncodePrecompiledCharsMap(
 
 #ifdef IS_BIG_ENDIAN
   uint32 *data = reinterpret_cast<uint32 *>(const_cast<char *>(blob.data()));
-  for (int i = 0; i <= trie_blob.size() / 4; ++i)
+  for (int i = 0; i <= blob.size() / 4; ++i)
     data[i] = util::Swap32(data[i]);
 #endif
+ 
+  blob.append(normalized.data(), normalized.size());
 
   return blob;
 }
@@ -279,8 +281,7 @@ util::Status Normalizer::DecodePrecompiledCharsMap(
   if (blob.size() <= sizeof(trie_blob_size) ||
       !string_util::DecodePOD<uint32>(
           absl::string_view(blob.data(), sizeof(trie_blob_size)),
-          &trie_blob_size) ||
-      trie_blob_size >= blob.size()) {
+          &trie_blob_size)) {
     return util::InternalError("Blob for normalization rule is broken.");
   }
 
@@ -294,9 +295,10 @@ util::Status Normalizer::DecodePrecompiledCharsMap(
   blob.remove_prefix(sizeof(trie_blob_size));
 
 #ifdef IS_BIG_ENDIAN
+  CHECK_OR_RETURN(buffer);
   buffer->assign(blob.data(), trie_blob_size);
   uint32 *data = reinterpret_cast<uint32 *>(const_cast<char *>(buffer->data()));
-  for (int i = 0; i < trie_blob_size / 4; ++i) data[i] = util::Swap32(data[i]);
+  for (int i = 0; i < buffer->size() / 4; ++i) data[i] = util::Swap32(data[i]);
   *trie_blob = absl::string_view(buffer->data(), trie_blob_size);
 #else
   *trie_blob = absl::string_view(blob.data(), trie_blob_size);
-- 
2.31.1

